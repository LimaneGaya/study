# Routing in Phoenix

Phoenix's router leverages macros for optimization, speed, safety, and error prevention in production.  These macros generate efficient code and help catch potential routing issues early.

You can list all defined routes using the `mix phx.routes` command.

## HTTP Verbs

Phoenix provides macros for all standard HTTP verbs: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`, `OPTIONS`, `CONNECT`, `TRACE`, and `HEAD`.  These correspond directly to the HTTP methods used for making requests.

## Resource Routing

The `resources` macro streamlines the definition of common RESTful routes and their corresponding controller actions.  For example:

```elixir
resources "/users", UserController
```

This single line generates routes for `index`, `show`, `new`, `create`, `edit`, `update`, and `delete` actions within the `UserController`.

### Limiting Routes with `:only` and `:except`

You can control which routes are generated by a `resources` macro using the `:only` and `:except` options.

- **`only:`**:  Specifies which actions to include.

```elixir
resources "/posts", PostController, only: [:index, :show]
```

This will only generate routes for the `index` and `show` actions.

- **`except:`**: Specifies which actions to exclude.

```elixir
resources "/comments", CommentController, except: [:delete]
```

This will generate routes for all actions except `delete`.


## Compile-Time Route Verification with `Phoenix.VerifiedRoutes`

The `Phoenix.VerifiedRoutes` module allows for compile-time verification of path references within your application. This helps prevent broken links and ensures route consistency.

To use it, include `use HelloWeb, :verified_routes` in your module, and then use the `~p` sigil to denote paths you want verified:

```elixir
defmodule RouteExample do
  use HelloWeb, :verified_routes

  def example do
    ~p"/comments" # This will be verified against your router
    ~p"/unknown/123" # This will cause a compile-time error if no matching route exists
  end
end
```

The `~p` sigil can be used throughout your web layer (routes, controllers, templates, and tests).  For example, in a controller:

```elixir
redirect(conn, to: ~p"/comments/#{comment}")
```

## Path Parameters and Query Strings with `~p`

The `~p` sigil also supports path parameters and query strings:

- **Path parameters:**  `~p"/users/#{user.id}"`

- **Query strings:** `~p"/users/17?#{[admin: true]}"` (This creates the URL `/users/17?admin=true`)


## Generating Full URLs

Use the `url` helper with the `~p` sigil to generate full URLs, including the host and port:

```elixir
url(~p"/users") # Might produce "http://localhost:4000/users"
```

## Nested Resources

You can nest resources to create hierarchical routes:

```elixir
resources "/users", UserController do
  resources "/posts", PostController
end
```

This generates routes like `/users/1/posts` and `/users/1/posts/2`.


## Scoped Routes

Scoped routes help organize routes and apply common behavior:

```elixir
scope "/admin", HelloWeb.Admin do
  pipe_through :browser  # Applies the :browser pipeline to all routes in this scope

  resources "/reviews", ReviewController # Routes will be like /admin/reviews
end
```

## Pipelines

Pipelines are a series of plugs that can be applied to a group of routes using the `pipe_through` macro within a scope.  Scopes can use multiple pipelines. Pipelines are commonly used for authentication, authorization, and other cross-cutting concerns.

## Forwarding Requests

The `forward` macro sends all requests matching a specific path to a specified plug:

```elixir
forward "/jobs", BackgroundJob.Plug
```

This sends all requests starting with `/jobs` to the `BackgroundJob.Plug` module.
